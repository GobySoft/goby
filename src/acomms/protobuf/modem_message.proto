import "goby/common/protobuf/option_extensions.proto";

package goby.acomms.protobuf;


message ModemTransmission
{
  optional int32 src = 1 [(goby.field).dccl.min = -1,
                          (goby.field).dccl.max = 30,
                          (goby.field).description = "modem ID of message source. 0 indicates BROADCAST.",
                          default = -1]; // 0 (BROADCAST), 1-30
  
  optional int32 dest = 2 [(goby.field).dccl.min = -1,
                           (goby.field).dccl.max = 30,
                           (goby.field).description = "modem ID of message destination. 0 indicates BROADCAST, -1 indicates QUERY_DESTINATION_ID (i.e., destination is set to the destination of the next available packet",
                           default = -1]; //  0 (BROADCAST), 1-30, -1 (QUERY_DESTINATION_ID)
  optional uint64 time = 3 [(goby.field).dccl.omit = true,
                            (goby.field).description = "timestamp (microseconds since UNIX (1970-01-01 00:00:00 UTC) of this transmission",
                            (goby.field).cfg.action = NEVER];
  enum TimeSource { MODEM_TIME = 1; GOBY_TIME = 2; } 
  optional TimeSource time_source = 5 [(goby.field).dccl.omit = true,
                                       default = GOBY_TIME,
                                       (goby.field).description = "source of the timestamp given",
                                       (goby.field).cfg.action = NEVER];
  optional int32 rate = 6 [(goby.field).dccl.min = -1,
                           (goby.field).dccl.max = 5,
                           (goby.field).description = "0 (lowest) - 5 (highest), -1 (QUERY_RATE). QUERY_RATE is currently unsupported by Goby-Queue",
                           default = 0];
  
  enum TransmissionType
  {
    // General (DriverBase) types
    UNKNOWN = 0;
    DATA = 1;
    ACK = 2;
    DRIVER_SPECIFIC = 10;
  }

  optional TransmissionType type = 7 [default = UNKNOWN,
                                      (goby.field).description="Type of this transmission. DRIVER_SPECIFIC types are enumerated in the extensions for the selected driver."];
  
  // for type == DATA
  optional uint32 max_num_frames = 11 [(goby.field).dccl.omit = true,
                                       default = 1,
                                       (goby.field).cfg.action = NEVER]; // set by the modem driver for the given rate
  optional uint32 max_frame_bytes = 12 [(goby.field).dccl.omit = true,
                                        (goby.field).cfg.action = NEVER]; // set by the modem driver for the given rate, omitted means no maximum
  optional bool ack_requested = 13 [default = true]; // acoustic acknowledgment requested
  repeated bytes frame = 14 [(goby.field).dccl.omit = true,
                             (goby.field).description="Data to transmit, represented as ASCII or octal bytes preceeded by a '\' (e.g. \000 is 0x00)"]; // if omitted, you will be queried for data on signal_data_request. You can also set some frames here and the rest will be filled by signalling a data request

  // for type == ACK
  repeated int32 acked_frame = 20 [(goby.field).dccl.omit = true,
                                   (goby.field).cfg.action = NEVER];
  

  // for AMAC
  optional double slot_seconds = 30 [(goby.field).dccl.min = 0, (goby.field).dccl.max = 20, (goby.field).dccl.precision=1, default = 10]; // length of slot (in seconds) if this transmission is part of a TDMA cycle
  optional uint32 unique_id = 31 [(goby.field).dccl.min = 0, (goby.field).dccl.max = 100, (goby.field).example="0"]; // used to assign an ID to this slot

  // extensions 1000-1100 used by mm_driver.proto
  // extensions 1201-1202 used by abc_driver.proto (example driver)
  // extensions 1300-1320 used by ufield_sim_driver.proto
  // extensions 1321-1340 used by pb_modem_driver.proto
  // extensions 1341-1360 used by udp_driver.proto  
  extensions 1000 to max;
}

message ModemRaw
{
  required string raw = 7; // "$CARXD,..."
  optional string description = 8; // "Incoming hexadecimal data"
}
